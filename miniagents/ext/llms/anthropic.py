"""
This module integrates Anthropic language models with MiniAgents.
"""

import typing
from functools import cache
from typing import Any, Optional

from pydantic import Field

from miniagents import Message
from miniagents.ext.llms.llm_utils import AssistantMessage, LLMAgent, message_to_llm_dict
from miniagents.messages import MessageSequence, MessageTokenAppender
from miniagents.miniagent_typing import MessageType
from miniagents.miniagents import miniagent

if typing.TYPE_CHECKING:
    import anthropic as anthropic_original


class AnthropicMessage(AssistantMessage):
    """
    A message generated by an Anthropic model.
    """


@cache
def _default_anthropic_client() -> "anthropic_original.AsyncAnthropic":
    try:
        # pylint: disable=import-outside-toplevel
        # noinspection PyShadowingNames
        import anthropic as anthropic_original
    except ModuleNotFoundError as exc:
        raise ImportError(
            "The 'anthropic' package is required for the 'anthropic' extension of MiniAgents. "
            "Please install it via 'pip install -U anthropic'."
        ) from exc

    return anthropic_original.AsyncAnthropic()


@miniagent
class AnthropicAgent(LLMAgent):
    """
    An agent that represents Large Language Models by Anthropic. Check out the implementation of the async `__call__`
    method in the base class `LLMAgent` to understand how agents like this one work (the two most important methods
    of all class-based miniagents are `__init__` and `__call__`).
    TODO explain parameters
    """

    fake_first_user_message: str = "/start"
    message_delimiter_for_same_role: str = "\n\n"
    async_client: Any = Field(default_factory=_default_anthropic_client)
    response_message_class: type[Message] = AnthropicMessage

    async def _aprepare_message_dicts(self) -> list[dict[str, Any]]:
        return await aprepare_dicts_for_anthropic(
            self.ctx.message_promises,
            system=self.system,
            message_delimiter_for_same_role=self.message_delimiter_for_same_role,
            fake_first_user_message=self.fake_first_user_message,
        )

    async def _aproduce_tokens(
        self, message_dicts: list[dict[str, Any]], token_appender: MessageTokenAppender
    ) -> None:
        system_message = await self._cut_off_system_message(message_dicts)

        if self.stream:
            async with self.async_client.messages.stream(
                messages=message_dicts,
                system=system_message,
                model=self.model,
                **self.__pydantic_extra__,
            ) as response:
                # TODO use non-text streaming so all the token metadata is available
                async for token in response.text_stream:
                    token_appender.append(self.response_message_class.token_class()(token))
                anthropic_final_message = await response.get_final_message()

        else:
            anthropic_final_message = await self.async_client.messages.create(
                messages=message_dicts,
                stream=False,
                system=system_message,
                model=self.model,
                **self.__pydantic_extra__,
            )

            if len(anthropic_final_message.content) != 1:
                raise RuntimeError(
                    f"exactly one TextBlock was expected from Anthropic, "
                    f"but {len(anthropic_final_message.content)} were returned instead"
                )
            # send the complete message content as a single token
            # TODO put all the token metadata into the token too (in this case metadata of complete message)
            token_appender.append(self.response_message_class.token_class()(anthropic_final_message.content[0].text))

        token_appender.auxiliary_field_collector.update(anthropic_final_message.model_dump(exclude={"content"}))

    async def _cut_off_system_message(self, message_dicts: list[dict[str, Any]]) -> str:
        if message_dicts and message_dicts[-1]["role"] == "system":
            # let's strip away the system message from the end (look at the implementation of
            # `aprepare_dicts_for_anthropic()` to see why it might be there)
            system_message_dict = message_dicts.pop()
            resulting_system_message = system_message_dict["content"]
        else:
            # if `self.system` was provided then it was already added by `aprepare_dicts_for_anthropic()`,
            # so this `else` branch is simply a "just in case" branch, it should never execute
            resulting_system_message = self.system

        if not resulting_system_message:
            # pylint: disable=import-outside-toplevel
            # noinspection PyShadowingNames
            import anthropic as anthropic_original

            resulting_system_message = anthropic_original.NOT_GIVEN

        return resulting_system_message


async def aprepare_dicts_for_anthropic(
    messages: MessageType,
    *,
    system: Optional[str] = None,
    message_delimiter_for_same_role: str = "\n\n",
    fake_first_user_message: str = "/start",
) -> list[dict[str, Any]]:
    message_dicts = [message_to_llm_dict(msg) for msg in await MessageSequence.turn_into_sequence_promise(messages)]
    if not message_dicts:
        return []

    non_system_message_dicts = [message_dict for message_dict in message_dicts if message_dict["role"] != "system"]
    if non_system_message_dicts and non_system_message_dicts[0]["role"] != "user":
        # Anthropic requires the first message to come from the user (system messages don't count -
        # their content will go into a separate, `system` parameter of the API call)
        non_system_message_dicts.insert(0, {"role": "user", "content": fake_first_user_message})

    system_message_dicts = [message_dict for message_dict in message_dicts if message_dict["role"] == "system"]
    # let's put all the system messages to the end (they will later be combined into a single message
    # and stripped away)
    message_dicts = non_system_message_dicts + system_message_dicts
    if system:
        message_dicts.append({"role": "system", "content": system})

    # if multiple messages with the same role are sent in a row, they should be concatenated (required by Anthropic)
    fixed_message_dicts = []
    for message_dict in message_dicts:
        if fixed_message_dicts and message_dict["role"] == fixed_message_dicts[-1]["role"]:
            fixed_message_dicts[-1]["content"] += message_delimiter_for_same_role + message_dict["content"]
        else:
            fixed_message_dicts.append(message_dict)

    return fixed_message_dicts
